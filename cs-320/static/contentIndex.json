{"Type-checking":{"slug":"Type-checking","filePath":"Type checking.md","title":"Type checking","links":[],"tags":[],"content":""},"exercises":{"slug":"exercises","filePath":"exercises.md","title":"exercises","links":["exercises/ex-01.pdf","exercises/ex-01-sol.pdf","exercises/ex-02.pdf","exercises/ex-02-sol.pdf","exercises/ex-03.pdf","exercises/ex-03-sol.pdf"],"tags":[],"content":"\nex-01.pdf\nex-01-sol.pdf\n\n\n\nex-02.pdf\nex-02-sol.pdf\n\n\n\nex-03.pdf\nex-03-sol.pdf\n"},"index":{"slug":"index","filePath":"index.md","title":"Computer Language Processing","links":["Topic/Minimising-Automata","pumping-Lema","Topic/Nullable-First-Follow","Topic/LL(1)","Topic/Left-recursion-elimination","Topic/Operational-Semantics","Type-checking"],"tags":[],"content":"Introduction to The project\nI realised that for me, the best way to get motivated to study a subject is to get tangible results from the learning that I can showcase.\nThis is the reason why, when a project or lab is released, I forget about everything else to finish it as fast as possible.\nSo in an attempt to motivate me to study the Theory of CS-320, I want to build this place where I will lay as clearly and as useful as possible all the knowledge acquired from this course.\nI start this project 10 days before the midterm, we’ll see what I have time to accomplish here by then.\nMain Topics\nWe will only treat what’s necessary to solve the exercises that you can find here\n\nMinimising Automata\npumping Lema\nNullable-First-Follow\nLL(1)\nLeft recursion elimination\nOperational Semantics\nType checking\n"},"lectures":{"slug":"lectures","filePath":"lectures.md","title":"lectures","links":["Lectures/CS-320-L01a.pdf","Lectures/CS-320-L01b.pdf","Lectures/CS-320-L02.pdf","Lectures/CS-320-lec03a.pdf","Lectures/CS-320-lec03b.pdf","Lectures/CS-320-lec04a.pdf","Lectures/CS-320-lec04b.pdf","Lectures/cs-320-lec05a.pdf","Lectures/cs-320-lec06a.pdf","Lectures/cs-320-lec06b.pdf","Lectures/cs-320-lec07a.pdf","Lectures/cs-320-lec07b.pdf"],"tags":[],"content":"CS-320 L01a.pdf\nCS-320 L01b.pdf\n\nCS-320 L02.pdf\n\nCS-320 lec03a.pdf\nCS-320 lec03b.pdf\n\nCS-320 lec04a.pdf\nCS-320 lec04b.pdf\n\ncs-320 lec05a.pdf\n\ncs-320 lec06a.pdf\ncs-320 lec06b.pdf\n\ncs-320 lec07a.pdf\ncs-320 lec07b.pdf"},"Topic/LL(1)":{"slug":"Topic/LL(1)","filePath":"Topic/LL(1).md","title":"LL(1)","links":[],"tags":[],"content":"Checking if LL(1)\n\n\nParsing tables\n\nThese two rules are sufficient to parse any tables\n"},"Topic/Left-recursion-elimination":{"slug":"Topic/Left-recursion-elimination","filePath":"Topic/Left recursion elimination.md","title":"Left recursion elimination","links":[],"tags":[],"content":"if you have\nA = Ab | c\nit becomes\nA = cA&#039;\nA&#039; = bA&#039; | \\epsilon"},"Topic/Minimising-Automata":{"slug":"Topic/Minimising-Automata","filePath":"Topic/Minimising Automata.md","title":"Minimising Automata","links":[],"tags":[],"content":""},"Topic/Nullable-First-Follow":{"slug":"Topic/Nullable-First-Follow","filePath":"Topic/Nullable-First-Follow.md","title":"Nullable-First-Follow","links":[],"tags":[],"content":"\nimg {  \n        display: block !important;  \n        margin-left: auto !important;  \n        margin-right: auto !important;  \n}  \n      \n .markdown-source-view.mod-cm6 .cm-content &gt; * {  \n        margin: auto auto !important;  \n}\n\nNote: We could use weather epsilon is in the first set to determine if a variable is nullable. But in this course we don’t put epsilon in the first set.\nNullable\n\nNon terminal is nullable if it can derive \\epsilon\nComputable with iterative solution over constraints if necessary.\nfor the iterative approach 0 if not nullable and we and and or\n\n\nFirst\nRules for First\n\nIf X is a terminal, then First(X) = \\{X\\}    \nFirst(X_{1}X_{2}\\dots X_{3}) = First(X_{1})  if X_{1} i.  not nullable. \nFirst(X_{1}X_{2}\\dots X_{p}) = First(X_{1}) \\cup First(X_{2}) \\cup \\dots \\cup First(X_{k}) if X_{1} up to X_{p-1} are nullable and X_{p} is not nullable or k=p \n\nRules for Sequences\nif X_1, X_2, ..., X_n are sequences of variables and terminals, then:\n\nSolving with Constraints\nAn easy example where constraints can be solved by substitution:\n\nComplex example which need the Iterative approach\n\n\n\nThe iterative approach uses set operations to determine the first set of a variable.\n\n\nFollow\n\n"},"Topic/Operational-Semantics":{"slug":"Topic/Operational-Semantics","filePath":"Topic/Operational Semantics.md","title":"Operational Semantics","links":[],"tags":[],"content":"No idea yet"},"Topic/Parsing-Tables":{"slug":"Topic/Parsing-Tables","filePath":"Topic/Parsing Tables.md","title":"Parsing Tables","links":[],"tags":[],"content":""},"Topic/Pumping-Lema":{"slug":"Topic/Pumping-Lema","filePath":"Topic/Pumping Lema.md","title":"Pumping Lema","links":[],"tags":[],"content":"Let L be a regular language over some alphabet \\Sigma. Then there exists a positive integer p (the pumping length of L) such that for every string s of length at least p, there exist strings x,y,z \\in \\Sigma^* such that\n\n|xy| \\leq p\ny \\neq \\epsilon\nxy^i z \\in L for all i \\geq 0\n"}}